#ifndef __JAVACLASSFILE_H__
#define __JAVACLASSFILE_H__

#include <memory>
#include <mutex>

#include "GlobalConstants.h"

#include "JavaCodeAttribute.h"
#include "ConstantPool.h"
#include "JavaClassConstants.h"
#include "MethodInfo.h"
#include "FieldInfo.h"
#include "InterfaceInfo.h"
#include "Lockable.h"

// Forward Declarations
class ObjectReference;
class ConstantPoolEntry;
class DefaultClassLoader; 
class ConstantPoolNameAndTypeDescriptor;

enum class e_PublicOnly
{
  No = 0,
  Yes = 1,
};

// enum e_JavaFieldAccessFlags : uint16_t
// {
//    e_JavaFieldAccessFlagPublic = 0x01      // Accessible outside the package
//   ,e_JavaFieldAccessFlagPrivate = 0x02     // Accessible only within the defining class
//   ,e_JavaFieldAccessFlagProtected = 0x04   // Accessible within subclasses
//   ,e_JavaFieldAccessFlagStatic = 0x08
//   ,e_JavaFieldAccessFlagFinal = 0x10       // Never assigned to after construction
//   ,e_JavaFieldAccessFlagVolatile = 0x40    // Can not be cached
//   ,e_JavaFieldAccessFlagTransient = 0x80   // Not written to or read by a persistent object manager
//   ,e_JavaFieldAccessFlagSynthetic = 0x1000 // Generated by the compiler. Does not appear in the source.
//   ,e_JavaFieldAccessFlagEnum = 0x4000      // Element of an enum
// };

class JavaClass
{
  // Only JavaClassFileLoaders are allowed to construct JavaClassFiles
  friend class ClassFactory;

protected:
  // It is assumed that the loader will create the ConstantPool object (using operator new) and pass it in.
  // The JavaClassFile will then take ownership of the constant pool and it should be be accessed again without going through the
  // class file.

  // The default ClassLoader is indicated by passing a NULL pointer.
  JavaClass( uint16_t minorVersion, uint16_t majorVersion, std::shared_ptr<ConstantPool> pConstantPool, uint16_t accessFlags, ConstantPoolIndex thisClassIndex, ConstantPoolIndex superClassIndex, InterfaceInfoList intefaces, FieldInfoList fields, MethodInfoList methods, CodeAttributeList attributes, boost::intrusive_ptr<ObjectReference> pClassLoader );

public:
  JavaClass( const JavaClass &other );
  JavaClass( JavaClass &&other ) JVMX_NOEXCEPT;

  JavaClass &operator=( JavaClass other );

  virtual ~JavaClass();

  virtual size_t CalculateInstanceSizeInBytes() const;

  virtual uint16_t GetMinorVersionNumber() const;
  virtual uint16_t GetMajorVersionNumber() const;
  virtual size_t GetConstantPoolCountAsDefinedByJava() const;
  virtual size_t GetNumberOfConstantsInConstantPool() const;
  virtual boost::intrusive_ptr<JavaString> GetName() const;
  virtual boost::intrusive_ptr<JavaString> GetSuperClassName() const;
  virtual std::shared_ptr<JavaClass> GetSuperClass();
  virtual boost::intrusive_ptr<ObjectReference> GetClassLoader() const;

  virtual size_t GetInterfacesCount() const;
  virtual const JavaString &GetInterfaceName( size_t interfaceIndex ) const;

  virtual size_t GetLocalFieldCount( e_PublicOnly publicOnly ) const;
  virtual size_t GetFieldCountIncludingSuperClasses() const;
  virtual size_t GetNonStaticFieldCount() const;
  virtual size_t GetLocalNonStaticFieldCount( e_PublicOnly publicOnly) const;

  void SetupSuperClass() const;

  virtual std::shared_ptr<FieldInfo> GetFieldByIndex( size_t fieldIndex ) const;
  virtual std::shared_ptr<FieldInfo> GetFieldByName( const JavaString &fieldName ) const;

  virtual size_t GetMethodCount() const;
  __declspec(deprecated) std::shared_ptr<MethodInfo> GetMethodByName( const JavaString &name ) const;
  virtual std::shared_ptr<MethodInfo> GetMethodByNameAndType( const JavaString &name, const JavaString &type ) const;

  virtual size_t GetMethodIndexByNameAndType( const JavaString &name, const JavaString &type ) const;
  virtual std::shared_ptr<MethodInfo> GetMethodByIndex( size_t index ) const;

  virtual size_t GetAttributeCount() const;
  virtual std::shared_ptr<JavaCodeAttribute> GetAttribute( size_t attributeIndex ) const;

  virtual uint16_t GetModifiers() const;

  virtual bool IsPublic() const;
  virtual bool IsFinal() const;
  virtual bool IsSuper() const;
  virtual bool IsInterface() const;
  virtual bool IsAbstract() const;
  virtual bool IsSynthetic() const;
  virtual bool IsAnnotation() const;
  virtual bool IsEnum() const;
  virtual bool IsInitialsed() const;
  virtual bool IsInitialsing() const;

  JavaString GetPackageName() const;

  virtual ConstantPoolEntry GetConstant( size_t index ) const;
  virtual std::shared_ptr<ConstantPool> GetConstantPool();

  virtual void SetInitialised();
  virtual void SetInitialising();

  virtual std::shared_ptr<Lockable> MonitorEnter( const char *pFunctionName );
  virtual void MonitorExit( const char *pFunctionName );

  virtual std::vector<boost::intrusive_ptr<IJavaVariableType>> GetAllStaticObjectsAndArrays() const;

  virtual std::recursive_mutex &GetInitialisationMutex();

protected:
  void swap( JavaClass &left, JavaClass &right ) JVMX_NOEXCEPT;

  virtual std::shared_ptr<ConstantPoolNameAndTypeDescriptor> GetNameAndTypeDescriptorFromConstantPool( ConstantPoolIndex index ) const;

  void SetupClassName();
  void SetupSuperClassName();
  void SetupMethods();

private:
  boost::intrusive_ptr<JavaString> m_pClassName;
  boost::intrusive_ptr<JavaString> m_pSuperClassName;
  boost::intrusive_ptr<ObjectReference> m_pClassLoader;

  mutable std::shared_ptr<JavaClass> m_pSuperClass;

  uint16_t m_AccessFlags;

  uint16_t m_MinorVersion;
  uint16_t m_MajorVersion;
  std::shared_ptr<ConstantPool> m_pConstantPool;

  ConstantPoolIndex m_ThisClassReferenceIndex;
  ConstantPoolIndex m_SuperClassReferenceIndex;
  InterfaceInfoList m_Interfaces;
  FieldInfoList m_Fields;

  MethodInfoList m_Methods;
  CodeAttributeList m_Attributes;

  bool m_Initialised;
  bool m_Initialising;

  std::shared_ptr<Lockable> m_pMonitor;
  mutable std::recursive_mutex m_InitialisationMutex;
};

#endif // __JAVACLASSFILE_H__
